
compose:
  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ imports }) => {
          const root = process.env.LCOD_RESOLVER_PATH && process.env.LCOD_RESOLVER_PATH.length > 0
            ? process.env.LCOD_RESOLVER_PATH
            : '.';
          const manifestPath = await imports.pathJoin({ base: root, segment: 'packages/std/lcp.toml' });
          console.log('register-components manifest', manifestPath.path);
          const manifestRaw = await imports.fsReadFile({ path: manifestPath.path, encoding: 'utf-8' });
          const manifestParsed = await imports.tomlParse({ text: manifestRaw.data ?? manifestRaw });
          console.log('manifest parsed keys', Object.keys(manifestParsed || {}));
          const components = [];
          const entries = manifestParsed?.value?.workspace?.components;
          if (Array.isArray(entries)) {
            for (const entry of entries) {
              if (!entry || typeof entry !== 'object') continue;
              const id = typeof entry.id === 'string' && entry.id.length > 0 ? entry.id : null;
              const relPath = typeof entry.path === 'string' && entry.path.length > 0 ? entry.path : null;
              if (!id || !relPath) continue;
              const composePath = await imports.pathJoin({ base: root, segment: `${relPath}/compose.yaml` });
              components.push({ id, composePath: composePath.path });
              console.log('register component', id, composePath.path);
            }
          }
          return { components };
        }
      imports:
        pathJoin: lcod://axiom/path/join@1
        fsReadFile: lcod://axiom/fs/read-file@1
        tomlParse: lcod://axiom/toml/parse@1
    out:
      componentDefs: components

  - call: lcod://tooling/resolver/register@1
    in:
      components: $.componentDefs
    out:
      registeredComponents: registered

  - call: lcod://tooling/registry_catalog.refresh@0.1.0
    in:
      rootPath: $env.LCOD_REGISTRY_ROOT ?? '.'
      catalogPath: 'catalog.json'
    out:
      refreshResult: $

  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }) => {
          const errors = Array.isArray(state.errors) ? state.errors : [];
          const warnings = Array.isArray(state.warnings) ? state.warnings : [];
          if (errors.length > 0) {
            throw new Error(`Registry refresh failed:\n${errors.join('\n')}`);
          }
          return { errors, warnings };
        }
      input:
        errors: $.refreshResult.errors
        warnings: $.refreshResult.warnings
    out:
      sanitizedErrors: errors
      sanitizedWarnings: warnings

  - call: lcod://tooling/registry_catalog.write_outputs@0.1.0
    in:
      rootPath: $env.LCOD_REGISTRY_ROOT ?? '.'
      packagesJsonl: $.refreshResult.packagesJsonl
      registryJson: $.refreshResult.registryJson
    out:
      writeUpdates: updates

  - call: lcod://impl/set@1
    in:
      errors: $.sanitizedErrors
      warnings: $.sanitizedWarnings
      updates: $.writeUpdates
    out:
      errors: errors
      warnings: warnings
      updates: updates
